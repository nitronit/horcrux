package pcosigner

import (
	"encoding/json"
	"os"

	cometjson "github.com/cometbft/cometbft/libs/json"
	"github.com/cometbft/cometbft/privval"
	tsed25519 "gitlab.com/unit410/threshold-ed25519/pkg"
)

// IThresholdSigner is interface for the cosigner_signer whether it's a soft sign or HSM
// Mainly for FUTURE use if and when we want to support HSM
type IThresholdSigner interface {
	// GetPubKey returns the persistent public key
	GetPubKey() []byte

	// GenerateNonces deals nonces for all cosigners.
	GenerateNonces() (Nonces, error)

	// Sign signs a byte payload using the a list of nonces.
	// Sign returns the partial signature and an error if any.
	Sign(nonces []Nonce, payload []byte) ([]byte, error)

	// CombineSignatures combines multiple partial signatures to a full signature.
	// FIX: not necessary this need to be in a Thresholdsigner?
	CombineSignatures([]PartialSignature) ([]byte, error)
}

// Nonces contains the ephemeral information generated by one cosigner for all other cosigners.
type Nonces struct {
	// PubKey is the public key for the generated nounces by cosigner
	PubKey []byte

	// Shares is the list nonces of size n generated by the cosigner.
	// Shares[i] is the nonce for cosigner i.
	Shares [][]byte
}

// Nonce is the ephemeral information from another cosigner destined for this cosigner.
type Nonce struct {
	ID     int
	Share  []byte
	PubKey []byte
}

// PartialSignature contains the partial signature and identifier (shamir id) of the signer.
type PartialSignature struct {
	ID        int
	Signature []byte
}

// CreateCosignerEd25519ShardsFromFile creates CosignerEd25519Key objects from a priv_validator_key.json file
func CreateCosignerEd25519ShardsFromFile(priv string, threshold, shards uint8) ([]CosignerEd25519Key, error) {
	pv, err := ReadPrivValidatorFile(priv)
	if err != nil {
		return nil, err
	}
	return CreateCosignerEd25519Shards(pv, threshold, shards), nil
}

// CreateCosignerEd25519Shards creates CosignerEd25519Key objects from a privval.FilePVKey
// by splitting the secret using Shamir secret sharing.
func CreateCosignerEd25519Shards(pv privval.FilePVKey, threshold, shards uint8) []CosignerEd25519Key {
	// tsed25519.DealShares splits the secret using Shamir Secret Sharing (Note its: no verifiable secret sharing)
	// privshards is shamir shares
	privShards := tsed25519.DealShares(tsed25519.ExpandSecret(pv.PrivKey.Bytes()[:32]), threshold, shards)
	out := make([]CosignerEd25519Key, shards)
	for i, shard := range privShards {
		out[i] = CosignerEd25519Key{
			PubKey:       pv.PubKey,
			PrivateShard: shard,
			ID:           i + 1,
		}
	}
	return out
}

// CreateCosignerRSAShards generate  CosignerRSAKey objects.
func CreateCosignerRSAShards(shards int) ([]CosignerRSAKey, error) {
	rsaKeys, pubKeys, err := makeRSAKeys(shards)
	if err != nil {
		return nil, err
	}
	out := make([]CosignerRSAKey, shards)
	for i, key := range rsaKeys {
		out[i] = CosignerRSAKey{
			ID:      i + 1,
			RSAKey:  *key,
			RSAPubs: pubKeys,
		}
	}
	return out, nil
}

// ReadPrivValidatorFile reads in a privval.FilePVKey from a given file.
func ReadPrivValidatorFile(priv string) (out privval.FilePVKey, err error) {
	var bz []byte
	if bz, err = os.ReadFile(priv); err != nil {
		return
	}
	if err = cometjson.Unmarshal(bz, &out); err != nil {
		return
	}
	return
}

// WriteCosignerEd25519ShardFile writes a cosigner Ed25519 key to a given file name.
func WriteCosignerEd25519ShardFile(cosigner CosignerEd25519Key, file string) error {
	jsonBytes, err := json.Marshal(&cosigner)
	if err != nil {
		return err
	}
	return os.WriteFile(file, jsonBytes, 0600)
}
